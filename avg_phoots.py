import argparse
import operator
import shlex
import subprocess
import sys
from collections import defaultdict, OrderedDict
from datetime import datetime, date
from functools import reduce
from os import listdir, makedirs, remove
from os.path import abspath, exists, isfile, isdir, join
from timeit import default_timer as timer

# note to self: i wasn't able to install py3exiv2, and i couldn't figure out
# how to access gexiv2 from python. so i decided to just write the metadata
# to the new images using the exiv2 command line interface.
#
# besides that, it looks like this stupid iptcinfo library is having trouble
# parsing the info if the image was generated by my leica. i have no idea if
# it's some text encoding issue or what, so what i will probably do is just 
# call the CLI for exiv2 again and parse the keywords out of that. ugly
# but the CLI is the only thing that's been any kind of reliable so far.
#
# in case you were wondering, the reason I have to read the IPTC data is
# because i group the images by day, but sometimes i include a photo taken
# after midnight in the previous day because that's how we humans think about
# it. i can get that info from the machine tag, which is in the IPTC data.

import cv2
import numpy as np
from skimage import exposure, io

from PIL import Image as Im
from PIL import ImageOps as ImOps
from PIL import ImageMath as ImMath
from PIL.ExifTags import TAGS

EXPOSURE_TIME = 'ExposureTime'
LANDSCAPE = 'landscape'
PORTRAIT = 'portrait'
SQUARE = 'square'
PAD = 'pad'
CROP = 'crop'

GET_IPTC_STRING = '/usr/local/bin/exiv2#-pi#{}'
SET_KEYWORD_STRING = 'add Iptc.Application2.Keywords String "{}"\n'
SET_CAPTION_STRING = 'set Iptc.Application2.Caption String "{}"\n'
SET_NAME_STRING = 'set Iptc.Application2.ObjectName String "{}"\n'
SET_MAKE_STRING = 'set Exif.Image.Make {}\n'
SET_MODEL_STRING = 'set Exif.Image.Model {}\n'
SET_SOFTWARE_STRING = 'set Exif.Image.Software {}\n'
SET_DATETIME_STRING = 'set Exif.Image.DateTime {}\n'
SET_IPTC_BYLINE_STRING = 'set Iptc.Application2.Byline String "{}"\n'
SET_ARTIST_STRING = 'set Exif.Image.Artist {}\n'
SET_EXIF_COPYRIGHT_STRING = 'set Exif.Image.Copyright {}\n'
SET_IPTC_COPYRIGHT_STRING = 'set Iptc.Application2.Copyright String "{}"\n'
WRITE_METADATA_STRING = '/usr/local/bin/exiv2#-m#{}#{}'
SOFTWARE_NAME = "photomanip v.0.1.0"
DATETIME_FMT = "%Y:%m:%d %H:%M:%S"

def call_command(cli_command):
    """Calls external command and returns stdout and stderr results.

    Args:
    command: An iterable containing the individual, space-delimited
    subcommands within a given cli command. In other words,
    a call to `./osx_AMRWBencoder 1 -dtx -itu ./somefile` would
    be represented as `

    ['./osx_AMRWBencoder', '1', '-dtx', '-itu', './somefile']`

    Returns:
    A tuple containing the stdout and stderr results of the call, as

    (stdout, stderr)
    """
    process = subprocess.Popen(cli_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    return process.communicate()

def set_image_metadata(fname, tag_list, caption, title, byline, copyright_str):
    fname = abspath(fname)
    text_fname = 'exiv2commands.txt'
    text_string = ''
    for tag in tag_list:
        text_string += SET_KEYWORD_STRING.format(tag)
    text_string += SET_CAPTION_STRING.format(caption)
    text_string += SET_NAME_STRING.format(title)
    text_string += SET_SOFTWARE_STRING.format(SOFTWARE_NAME)
    datetime_str = datetime.now().strftime(DATETIME_FMT)
    text_string += SET_DATETIME_STRING.format(datetime_str)
    text_string += SET_IPTC_BYLINE_STRING.format(byline)
    text_string += SET_IPTC_COPYRIGHT_STRING.format(copyright_str)
    text_string += SET_ARTIST_STRING.format(byline)
    text_string += SET_EXIF_COPYRIGHT_STRING.format(copyright_str)
    # write the string out
    with open(text_fname, 'w') as text_file:
        print(text_string, file=text_file)
    # call exiv2
    std_out, std_err = call_command(WRITE_METADATA_STRING.format(text_fname, fname).split('#'))
    remove(text_fname)

class ImageTools(object):
    """Loads an image using PIL and calculates exposure time, image width and height,
     prepares an image for further processing, and splits an image into red, green
     and blue channels and scales the output based on a specified scale factor."""
    def __init__(self, fname, library='pil'):
        # TODO: refactor this so we're not opening the image twice
        # NOTE: this will require updating `_calculate_exposure_time_in_s` to not
        # depend on PIL
        self.filename = fname
        self.this_image = Im.open(fname)
        self.width, self.height = self.this_image.size
        self._calculate_exposure_time_in_s()
        self.library = library
        # now do the IPTC stuff
        self._get_iptc_keywords()
        # if we'd rather use openCV, replace the PIL version.
        if self.library == 'cv2':
            self.this_image = cv2.imread(fname,cv2.IMREAD_COLOR)


    def _get_iptc_keywords(self):
        std_out, std_err = call_command(GET_IPTC_STRING.format(self.filename).split('#'))
        if std_err:
            traceback = sys.exc_info()[2]
            raise ChildProcessError("unable to get IPTC string: {}".format(std_err))\
                .with_traceback(traceback)
        self.tags = []
        lines = [line for line in std_out.decode().split('\n') if line.strip() != '']
        for line in lines:
            # trap for single quotes that tend to show up in the caption and mess up shlex.split()
            line = line.replace("\'", "")
            line_parts = shlex.split(line)
            if line_parts[0] == 'Iptc.Application2.Keywords':
                tag = line_parts[3]
                self.tags.append(tag)

    def get_tags_containing(self, search_term):
        tags = [tag for tag in self.tags if search_term in tag]
        if len(tags) == 1:
            tags = tags[0]
        return tags

    def _calculate_exposure_time_in_s(self):
        """Reads the EXIF data from the image file and calculates the exposure time
         in seconds."""
        self.exif_data = {}
        info = self.this_image._getexif()
        for tag, value in info.items():
            decoded = TAGS.get(tag, tag)
            self.exif_data[decoded] = value
        self.exposure_time = self.exif_data[EXPOSURE_TIME]
        self.exposure_time_in_s = (float(self.exposure_time[0])) / (float(self.exposure_time[1]))

    def prepare_image(self, comb_method, final_dimension):
        """Ensures an image has even dimensions, determines the images orientation,
         and either pads or crops an image to a specified final dimension."""
        self._get_image_orientation()
        if self.library == 'cv2':
            self._even_image_cv2()
            self._pad_or_crop_cv2(comb_method, final_dimension)
        else:
            self._even_image_pil()
            self._pad_or_crop_pil(comb_method, final_dimension)

    def _even_image_pil(self):
        """Ensures an image has even dimensions."""
        if (self.width % 2) == 1:
            # crop the width by 1
            self.this_image = self.this_image.crop((1, 0, self.width, self.height))
            self.width, self.height = self.this_image.size
        if (self.height % 2) == 1:
            # crop the height by 1
            self.this_image = self.this_image.crop((0, 1, self.width, self.height))
            self.width, self.height = self.this_image.size


    def _even_image_cv2(self):
        """Ensures an image has even dimensions."""
        if (self.width % 2) == 1:
            # crop the width by 1
            self.this_image = self.this_image[0:self.height, 1:self.width]
            self.height, self.width, _ = self.this_image.shape
        if (self.height % 2) == 1:
            # crop the height by 1
            self.this_image = self.this_image[1:self.height, 0:self.width]
            self.height, self.width, _ = self.this_image.shape


    def _get_image_orientation(self):
        """Determines the orientation of an image."""
        # do a cheap trick to determine orientation
        if self.width > self.height:
            # image is landscape
            self.image_orientation = LANDSCAPE
        elif self.width < self.height:
            # image is portrait
            self.image_orientation = PORTRAIT
        elif self.width == self.height:
            # image is square
            self.image_orientation = SQUARE


    def _pad_or_crop_pil(self, comb_method, output_dimension):
        """Wrapper function that calls the method to either pad or crop an image based
         on input."""
        if comb_method == PAD:
            self._pad_image_pil(output_dimension)
        elif comb_method == CROP:
            self._square_image_pil(output_dimension)
        else:
            raise ValueError('invalid value for combination_method')


    def _pad_or_crop_cv2(self, comb_method, output_dimension):
        """Wrapper function that calls the method to either pad or crop an image based
         on input."""
        if comb_method == PAD:
            self._pad_image_cv2(output_dimension)
        elif comb_method == CROP:
            self._square_image_cv2(output_dimension)
        else:
            raise ValueError('invalid value for combination_method')


    def _pad_image_pil(self, expand_to):
        """Pads an image to a specified dimension."""
        # this is needed to find the smallest dim so we can expand that to `expand_to`
        min_dim = min(self.width, self.height)
        pad_amount = (expand_to - min_dim) / 2
        padded_image = ImOps.expand(
            self.this_image, border=pad_amount, fill=(255, 255, 255))
        width, height = padded_image.size
        max_dim = max(width, height)
        crop_amount = (max_dim - expand_to) / 2
        if self.image_orientation == LANDSCAPE:
            self.this_image = padded_image.crop(
                (crop_amount, 0, width - crop_amount, height))
            self.width, self.height = self.this_image.size
        elif self.image_orientation == PORTRAIT:
            self.this_image = padded_image.crop(
                (0, crop_amount, width, height - crop_amount))
            self.width, self.height = self.this_image.size
        elif self.image_orientation == SQUARE:
            # don't think I need to do anything here.
            pass


    def _square_image_pil(self, crop_to):
        """Crops an image to a specified dimension."""
        # this is needed to find the largest dim so we can crop that to `crop_to`
        w_crop_amount = (self.width - crop_to) / 2
        h_crop_amount = (self.height - crop_to) / 2
        self.this_image = self.this_image.crop(
            (w_crop_amount, h_crop_amount, self.width - w_crop_amount,
             self.height - h_crop_amount))


    def _pad_image_cv2(self, expand_to):
        """Pads an image to a specified dimension."""
        # this is needed to find the smallest dim so we can expand that to `expand_to`
        # min_dim = min(self.width, self.height)
        # pad_amount = (expand_to - min_dim) / 2
        padded_image = 255 * np.ones((expand_to, expand_to, 3))
        upper_left = (((expand_to - self.height) // 2), ((expand_to - self.width) // 2))
        lower_right = ((upper_left[0] + self.height), (upper_left[1] + self.width))
        padded_image[upper_left[0]:lower_right[0], upper_left[1]:lower_right[1], :] =\
            self.this_image
        self.this_image = padded_image
        # raise ValueError("Padding an image using OpenCV is not supported (yet).")


    def _square_image_cv2(self, crop_to):
        """Crops an image to a specified dimension."""
        # this is needed to find the largest dim so we can crop that to `crop_to`
        w_crop_amount = (self.width - crop_to) // 2
        h_crop_amount = (self.height - crop_to) // 2
        self.this_image = self.this_image[
            h_crop_amount:self.height - h_crop_amount,
            w_crop_amount:self.width - w_crop_amount]


    def _split_scale_pil(self, scale_factor):
        """Splits an image into red, green, and blue channels and scales
         each channel by specified scale factor."""
        r_im, g_im, b_im = self.this_image.split()
        r_im = ImMath.eval("convert(a, 'F')", a=r_im)
        r_im = ImMath.eval("a * b", a=r_im, b=scale_factor)
        g_im = ImMath.eval("convert(a, 'F')", a=g_im)
        g_im = ImMath.eval("a * b", a=g_im, b=scale_factor)
        b_im = ImMath.eval("convert(a, 'F')", a=b_im)
        b_im = ImMath.eval("a * b", a=b_im, b=scale_factor)
        return r_im, g_im, b_im


    def _split_scale_cv2(self, divisor):
        """Divides `self.this_image` by a divisor and returns it."""
        # actually i am not sure how much sense it makes to do the averaging
        # in the HSV color space.
        return self.this_image / divisor


    def split_scale_image(self, scale_factor):
        """Delegates splitting and scaling responsibility to the appropriate
        method."""
        if self.library == 'cv2':
            return self._split_scale_cv2(scale_factor)
        else:
            return self._split_scale_pil(scale_factor)


# code sample from http://effbot.org/zone/pil-histogram-equalization.htm -------
def equalize(h):
    """Applies histogram equalization to a seficied histogram."""
    lut = []
    for b in range(0, len(h), 256):
        # step size
        step = reduce(operator.add, h[b:b + 256]) / 255
        # create equalization lookup table
        n = 0
        for i in range(256):
            lut.append(n / step)
            n = n + h[i + b]
    return lut
# code sample from http://effbot.org/zone/pil-histogram-equalization.htm -------


def get_phoot_list(dir_name, extension='.jpg'):
    """Gets a list of files with extension `extension` (default '.jpg') in a folder."""
    onlyfiles = [join(dir_name, f) for f in listdir(dir_name)
                 if isfile(join(dir_name, f)) and f.endswith(extension)]
    return onlyfiles

def print_status(curr_fname, curr_image, total_images):
    """Prints the status of the processing run based on input."""
    print("processing {} ({} of {})".format(curr_fname, str(curr_image),
                                            str(total_images)))


def get_final_dimension(comb_method, image_widths, image_heights):
    """Computes the dimensions of the final output image based on specified
     combination method and lists of images widths and heights."""
    if comb_method == PAD:
        max_w = max(image_widths)
        max_h = max(image_heights)
        expand_to = max(max_w, max_h)
        if (expand_to % 2) == 1:
            expand_to -= 1
        return expand_to
    elif comb_method == CROP:
        min_w = min(image_widths)
        min_h = min(image_heights)
        crop_to = min(min_w, min_h)
        if (crop_to % 2) == 1:
            crop_to -= 1
        return crop_to
    else:
        raise ValueError('invalid value for combination_method')


def combine_images_pil(phoot_list, combination_method, output_dimension, out_name):
    """Uses PIL and associated methods to "average" a list of photographs. """
    num_images = len(phoot_list)
    fname = phoot_list[0]
    print_status(fname, 1, num_images)
    current_image = ImageTools(fname, 'pil')
    current_image.prepare_image(combination_method, output_dimension)
    phoot_list.pop(0)
    r_comp_im, g_comp_im, b_comp_im = current_image.split_scale_image((1.0 / num_images))

    # now loop through the list again and first crop or expand the images
    # and then combine them.
    progress_counter = 1
    for fname in phoot_list:
        progress_counter += 1
        print_status(fname, progress_counter, num_images)
        current_image = ImageTools(fname, 'pil')
        current_image.prepare_image(combination_method, output_dimension)
        this_r, this_g, this_b = current_image.split_scale_image((1.0 / num_images))
        # now add them together
        r_comp_im = ImMath.eval("a + b", a=r_comp_im, b=this_r)
        g_comp_im = ImMath.eval("a + b", a=g_comp_im, b=this_g)
        b_comp_im = ImMath.eval("a + b", a=b_comp_im, b=this_b)

    # finally convert them back to ints and then merge the image before display.
    r_comp_im = ImMath.eval("convert(a, 'L')", a=r_comp_im)
    g_comp_im = ImMath.eval("convert(a, 'L')", a=g_comp_im)
    b_comp_im = ImMath.eval("convert(a, 'L')", a=b_comp_im)

    # now that everything has been added together, do some histogram equalization
    r_lut = equalize(r_comp_im.histogram())
    g_lut = equalize(g_comp_im.histogram())
    b_lut = equalize(b_comp_im.histogram())

    r_comp_im = r_comp_im.point(r_lut)
    g_comp_im = g_comp_im.point(g_lut)
    b_comp_im = b_comp_im.point(b_lut)

    composite_image = Im.merge('RGB', (r_comp_im, g_comp_im, b_comp_im))

    # composite_image.show()
    composite_image.save(out_name)

def combine_images_cv2(phoot_list, combination_method, output_dimension, out_name):
    """Uses OpenCV and associated methods to "average" a list of photographs. """
    num_images = len(phoot_list)
    fname = phoot_list[0]
    print_status(fname, 1, num_images)
    current_image = ImageTools(fname, 'cv2')
    current_image.prepare_image(combination_method, output_dimension)
    phoot_list.pop(0)

    composite_image = current_image.split_scale_image(num_images)

    # now loop through the images, crop or expand them, and then combine.
    progress_counter = 1
    for fname in phoot_list:
        progress_counter += 1
        print_status(fname, progress_counter, num_images)
        current_image = ImageTools(fname, 'cv2')
        current_image.prepare_image(combination_method, output_dimension)
        scaled_image = current_image.split_scale_image(num_images)
        composite_image += scaled_image

    # various strategies for histogram equalization follow.
    # TODO: split these out into different functions so it's possible to access
    # all of them.
    # hsv_image = cv2.cvtColor(composite_image.astype('uint8'), cv2.COLOR_BGR2HSV)
    # hsv_image[:, :, 2] = cv2.equalizeHist(hsv_image[:, :, 2])
    # equalized_image = cv2.cvtColor(hsv_image, cv2.COLOR_HSV2BGR)

    # hls_image = cv2.cvtColor(composite_image.astype('uint8'), cv2.COLOR_BGR2HLS)
    # hls_image[:, :, 1] = cv2.equalizeHist(hls_image[:, :, 1])
    # equalized_image = cv2.cvtColor(hls_image, cv2.COLOR_HLS2BGR)

    # equalized_image = composite_image.astype('uint8')
    # clahe = cv2.createCLAHE()
    # equalized_image[:, :, 0] = clahe.apply(equalized_image[:, :, 0])
    # equalized_image[:, :, 1] = clahe.apply(equalized_image[:, :, 1])
    # equalized_image[:, :, 2] = clahe.apply(equalized_image[:, :, 2])

    # equalized_image = composite_image.astype('uint8')
    # equalized_image[:, :, 0] = cv2.equalizeHist(equalized_image[:, :, 0])
    # equalized_image[:, :, 1] = cv2.equalizeHist(equalized_image[:, :, 1])
    # equalized_image[:, :, 2] = cv2.equalizeHist(equalized_image[:, :, 2])
    # cv2.imwrite(out_name, equalized_image)

    # Contrast stretching
    data_mask = composite_image != 255
    lower_bound, upper_bound = np.percentile(composite_image[data_mask], (0.5, 99.5))
    composite_image[data_mask] = exposure.rescale_intensity(composite_image[data_mask],
                                                          in_range=(lower_bound, upper_bound),
                                                          out_range='uint8')

    cv2.imwrite(out_name, composite_image)

COMBINATION_METHODS = {'pil': combine_images_pil,
                       'cv2': combine_images_cv2}

def average_dir(img_path, combination_method, out_name, library='pil', **kwargs):
    """Averages, or makes a multiple exposure of all the photos in a specified
     directory."""
    # first take on special naming/tagging parameters
    if 'month' in kwargs:
        month = kwargs['month']
        long_month_name = date(1984, int(month), 1).strftime('%B').lower()
        short_month_name = date(1984, int(month), 1).strftime('%b').lower()
    if 'year' in kwargs:
        year = kwargs['year']

    # okay, let's get a list of phoots
    phoot_list = get_phoot_list(img_path)

    # init some vars to store exposure time, etc.
    exposure_times = []
    image_widths = []
    image_heights = []
    total_shutter_open = 0

    # now loop through the list of files and get exposure times and max dimensions
    for fname in phoot_list:
        current_image = ImageTools(fname, 'pil')
        this_exposure = current_image.exposure_time_in_s
        exposure_times.append(this_exposure)
        total_shutter_open += this_exposure
        # get the dimensions
        width, height = current_image.width, current_image.height
        image_widths.append(width)
        image_heights.append(height)

    # now that we have the total length, calculate scale factors---
    # depending on how you think about making a multiple exposure, scaling by
    # the total amount of time the shutter was open is the correct way to go.
    # this time around, though, we'll just approach it more like an average.
    # scale_factors = []
    # for exp_time in exposure_times:
    #     scale_factors.append(exp_time / total_shutter_open)

    output_dimension = get_final_dimension(combination_method, image_widths, image_heights)

    start = timer()
    if library == 'cv2':
        print("using opencv for image processing")
        combine_images_cv2(phoot_list, combination_method, output_dimension, out_name)
    elif library == 'pil':
        print("using pil for image processing")
        combine_images_pil(phoot_list, combination_method, output_dimension, out_name)
    out_tag_list = ['multiple exposure',
                    'art',
                    'average',
                    'python',
                    'opencv']
    if month and year:
        caption = 'average of all daily photos published {} {}\\n\\ntotal exposure time in seconds: {}'\
            .format(long_month_name, year, total_shutter_open)
        title = 'avg {}'.format(short_month_name)
        out_tag_list.append(year)
        out_tag_list.append(long_month_name)
        num_images = len(phoot_list)
        out_tag_list.append('avgmonth:count={}'.format(num_images))
        out_tag_list.append('avgmonth:date={}{}'.format(year, month))
    else:
        caption = 'average of photos\\n\\ntotal exposure time in seconds: {}'\
            .format(total_shutter_open)
        title = 'avg'
    set_image_metadata(out_name, out_tag_list, caption, title, 'andrew catellier', 'all rights reserved')
    end = timer()

    print("minimum image dimension: {} pixels".format(str(min(min(image_widths),
                                                              min(image_heights)))))
    print("maximum image dimension: {} pixels".format(str(max(max(image_widths),
                                                              max(image_heights)))))
    print("total exposure time in seconds: {}".format(str(total_shutter_open)))
    print("processing time in seconds: {}".format(end - start))

def average_each_day(img_path, combination_method, out_path, library='cv2', grouping_tag='faceit365'):
    """Averages, or makes a multiple exposure of all the photos in a specified
     directory, grouped by day. The photos of each day will be made into a
     multiple exposure."""

    """['DateTimeOriginal']:'2012:03:02 18:09:17'
    ['DateTimeDigitized']:'2012:03:02 18:09:17'"""
    # okay, let's get a list of phoots
    phoot_list = get_phoot_list(img_path)

    # loop through all the files and make a dict to key track of things
    photo_info_by_day = defaultdict(list)

    # init some vars to store exposure time, etc.
    # total_shutter_open = 0
    if not exists(out_path):
        makedirs(out_path)

    # now loop through the list of files and get exposure times and max dimensions
    for fname in phoot_list:
        current_image = ImageTools(fname, 'pil')
        grouping_tags = current_image.get_tags_containing(grouping_tag)
        if any(grouping_tags):
            day_key = grouping_tags[-8:]
        else:
            image_date = current_image.exif_data['DateTimeOriginal']
            day_key = image_date[:-9].replace(':', '')
        photo_info_by_day[day_key].append({'filename': fname,
                                           'exposure_time': current_image.exposure_time_in_s,
                                           'hxw': (current_image.width, current_image.height)})

    # sort the dict so averages are generated in order
    photo_info_by_day = OrderedDict(sorted(photo_info_by_day.items()))
    # get some month and day info for filename and tag purposes---
    # this is ugly and not ideal but it will do for now
    processed_year = day_key[:4]
    # everything is a little more organized now. Loop through the days and make a bunch of images.
    start = timer()
    print("using {} for image processing".format(library))
    print("now processing daily images")
    combine_function = COMBINATION_METHODS[library]
    all_photos = []
    for date, photo_list in photo_info_by_day.items():
        all_photos.extend(photo_list)
        if len(photo_list) == 1:
            print("only one photo for {}, skipping".format(date))
            continue
        current_month = date[4:6]
        out_name = join(out_path, current_month, date + '.jpg')
        # do a quick check to see if this image has already been generated
        if isfile(out_name):
            print("file {} already generated".format(out_name))
            continue
        phoot_list = []
        image_widths = []
        image_heights = []
        exposure_times = []
        total_shutter_open = 0
        for photo in photo_list:
            phoot_list.append(photo['filename'])
            image_widths.append(photo['hxw'][0])
            image_heights.append(photo['hxw'][1])
            exposure_times.append(photo['exposure_time'])
            total_shutter_open += photo['exposure_time']
        output_dimension = get_final_dimension(combination_method, image_widths, image_heights)
        combine_function(phoot_list, combination_method, output_dimension, out_name)
        num_images = len(photo_list)
        out_tag_list = ['avgday:date={}'.format(date),
                        'avgday:count={}'.format(num_images),
                        processed_year,
                        'multiple exposure',
                        'art',
                        'average',
                        'python',
                        'opencv']
        caption = '{num:0{width}} image exposure\\n{sec:.4f} seconds exposed'\
            .format(num=num_images, width=6, sec=total_shutter_open)
        title = 'avg{}'.format(date)
        set_image_metadata(out_name, out_tag_list, caption, title, 'andrew catellier', 'all rights reserved')
        print("minimum image dimension: {} pixels".format(str(min(min(image_widths),
                                                                min(image_heights)))))
        print("maximum image dimension: {} pixels".format(str(max(max(image_widths),
                                                                max(image_heights)))))
        print("total exposure time in seconds: {}".format(str(total_shutter_open)))
    end = timer()
    print("seconds elapsed processing daily images: {}".format(end - start))

    # print("now processing images for entire month")
    # avg_month_name = join(out_path, 'avg{}{}.jpg'.format(processed_year, processed_month))
    # naming_deets = {'month': processed_month,
    #                 'year': processed_year}
    # average_dir(img_path, combination_method, avg_month_name, library, **naming_deets)


def main():
    """Main function to parse commandline arguments and start the averaginge function."""
    parser = argparse.ArgumentParser()
    parser.add_argument("img_path", help="path of the directory of images you'd like to process")
    parser.add_argument("combination_method",
                        help="""either 'crop' (all images are cropped to smallest dimension) \
                                or 'pad' (all images are padded to largest dimension))""")
    parser.add_argument("out_name", help="name of averaged output file including extension")
    parser.add_argument("library", help="specify which image library to use—either 'cv2' or 'pil'")
    args = parser.parse_args()

    if args.library and (args.library == "cv2"):
        # first average each day
        average_each_day(args.img_path, args.combination_method, args.out_name,
                         args.library)
        # # then average each month by dir
        # dir_list = [item for item in listdir(args.out_name) if isdir(join(args.out_name, item))]
        # # specify what year we're working because i'm lazy
        # year_arg = '2018'
        # for directory in dir_list:
        #     avg_month_name = join(args.out_name, 'avg{}{}.jpg'.format(year_arg, directory))
        #     naming_deets = {'month': directory,
        #                     'year': year_arg}
        #     img_path = join(args.out_name, directory)
        #     average_dir(img_path, args.combination_method, avg_month_name, args.library, **naming_deets)

    elif args.library and (args.library == "pil"):
        average_dir(args.img_path, args.combination_method, args.out_name,
                    args.library)
    elif not args.library:
        print("No imaging library specified, using PIL.")
        average_dir(args.img_path, args.combination_method, args.out_name,
                    "pil")
    else:
        raise ValueError("{} is not a valid imaging library. Choose either 'pil' or 'cv2'"
                         .format(args.library))

if __name__ == "__main__":
    main()
